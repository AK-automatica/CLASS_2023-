---
title: "07_functions_2"
author: "JR"
date: "8/1/2022"
output: html_document
editor_options: 
  chunk_output_type: console
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
options(stringsAsFactors = F)
library(GenomicRanges)
library(tidyverse)
library(IRanges)
source("../../util/my_class_functions.R")

basepath <- "/scratch/Shares/rinnclass/CLASS_2023/JR"
peak_path <- "CLASS_2023/CLASSES/03_Nextflow/00_my_chipseq/results/bwa/mergedLibrary/macs/broadPeak/"
broadpeakfilepath <- file.path(basepath, peak_path)

```

# interesect peaks custom function
In the previous class we created a function to import peak files as a GRanges.
We can now use this to find overlaps in replicates using another function
"intersect peaks" Let's take a look at our "intersect_peaks" function. 


Let's first run import_peaks 

```{r import peaks}

# import peaks to get peak_list
peak_list <- import_peaks(consensus_file_path = broadpeakfilepath)

# This will be the input into our intersect_peaks function
```

Now that we have a named list of GRanges for each peak file 
We can export them as consensus peak files


Now let's create consensus peaks where all peaks overlap 
This is a lot so hang in there ;)
```{r consensus peaks function}

# import peaks as named GRange list
peak_list <- import_peaks(consensus_file_path = broadpeakfilepath)

# getting dbp name as object -- problem is rep number won't work
# we need a unique DBP name with out the replicate as input to for loop
names(peak_list)

# let's use unlist(strsplit) on names to get a unique name for each DBP
dbps <- unique(sapply(names(peak_list), function(x) {
   unlist(strsplit(x, "_"))[1]
}))

# Now we can make a function to find peaks in all samples!!

# setting up function and parameters (dbp and peak_list)
consensus_from_reduced <- function(dbp, peak_list) {
  
# index into list of Granges for each replicate for each dbp
  dbp_peaks <- peak_list[grepl(as.character(dbp), names(peak_list))]
  
  # this will unlist the Granges for each of the dbps "unlist"
  # This makes a list of all the peaks in all the file and takes union of overlaps
  suppressWarnings(all_peaks <- GenomicRanges::reduce(unlist(as(dbp_peaks, "GRangesList"))))
  
  # Make a matrix of all peaks and the cols will be the replicate for each DBP
  peak_exists <- matrix(NA, nrow = length(all_peaks), ncol = length(dbp_peaks))
  
  # for loop to "countOverlaps" for each replicate
  for(i in 1:length(dbp_peaks)) {
    
    # indexing into peak_exists -- all rows and ith col 
    # this is then populated with overlaps
    suppressWarnings(peak_exists[,i] <- as.numeric(countOverlaps(all_peaks, dbp_peaks[[i]]) > 0))
  }
  
  # filter to consensus requiring peaks to be in all replicates
  dbp_consensus <- all_peaks[rowSums(peak_exists) == ncol(peak_exists)]
  # Required only two replicates
  # dbp_consensus <- all_peaks[rowSums(peak_exists) > 1]
  return(dbp_consensus)
}

# Now run consensus_from_reduced on peak_list
# parameters: dbps (unique dbp names, function = consensu_from_reduced, peaks_list of Granges)
consensus_list <- lapply(dbps, consensus_from_reduced, peak_list)

# adding names to results
names(consensus_list) <- dbps

# determining then length of resulting consensus peaks
num_peaks <- sapply(consensus_list, length)

# setting file path to export
basepath <- "/scratch/Shares/rinnclass/CLASS_2023/<your_folder>"
consensus_path <- "CLASS_2023/CLASSES/04_R_basics/results/consensus_peaks/"
exportpath <- file.path(basepath, consensus_path)

# now we can export each as .bed file
for(i in 1:length(consensus_list)) {
rtracklayer::export(consensus_list[[i]], paste0(exportpath, names(consensus_list)[i], "_consensus_peaks.bed") )}


```


















# for loop to export peak_files into .bed

```{r export peak files from peak_list}

# export peak files from named list of GRanges (peak_list) 
# for loop to export

dbp <- names(peak_list)

for(i in 1:length(dbp)) {
rtracklayer::export(peak_list[[i]], 
paste0("results/consensus_peaks/", names(peak_list)[i], "_peaks.broadPeak")) }


# excellent now we have .bed files for our consensus peaks let's look at one:

peak_1 <- read_tsv("results/consensus_peaks/EP300_R1_peaks.bed", col_names = F)

names(peak_1) <- c('chromosome', 'start', 'end', 'name', 'score', 'strand', 
                       'signalValue', 'pValue', 'qValue')

# add col names


# note we have the same issue

```










# Intersect peaks function (version 1 )
```{r creating intersect_peaks function}
# note the dependence on peak_list which is the output of import_peaks.

intersect_peaks <- function(peak_list) {
  
  combined_peaks <- peak_list[[1]]
  for(i in 2:length(peak_list)) {
    suppressWarnings(pl_ov <- findOverlaps(combined_peaks, peak_list[[1]]))
    pl1 <- combined_peaks[unique(pl_ov@from)]
    pl2 <- peak_list[[i]][unique(pl_ov@to)]
    suppressWarnings(combined_peaks <- GenomicRanges::reduce(union(pl1, pl2)))
    
  }
  return(combined_peaks)
}
# Now that we have this function in this environment session we
# could just run it like this:
overlaps <- intersect_peaks(peak_list)
```

# ***** Let's add this as a function in our util ******
